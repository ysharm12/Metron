Below is an updated Streamlit app that meets your requirements. It has the following improvements:

- **Simplified prompts:** The prompts now use minimal language and avoid disclosing internal details.  
- **Autonomous processing:** The SQL queries generated by Azure OpenAI are not shown to the end user (unless debug mode is enabled).  
- **Debug mode support:** When enabled via a sidebar checkbox, internal SQL and JSON outputs are displayed to aid debugging.

Save this code as, for example, **streamlit_app.py**, and run it with:

```bash
streamlit run streamlit_app.py
```

Here’s the updated code:

```python
import streamlit as st
import duckdb
import re
import json
import logging
from openai import AzureOpenAI

# Configure logging for debugging.
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(),  # Log to console.
        logging.FileHandler("app_debug.log", mode="w")  # Log to file.
    ]
)

def generate_sql(client, prompt, model="o1-preview"):
    """
    Generate a SQL query or JSON output from a natural language prompt.
    """
    try:
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            timeout=300
        )
        raw_output = response.choices[0].message.content.strip()
        # Extract text wrapped in triple backticks (if present)
        pattern = r"```(?:sql)?\s*(.*?)\s*```"
        match = re.search(pattern, raw_output, re.DOTALL)
        if match:
            return match.group(1).strip()
        else:
            return raw_output
    except Exception as e:
        logging.exception("Error in generate_sql")
        raise

def generate_marketing_content(client, prompt, model="o1-preview"):
    """
    Generate multi-channel marketing content from a prompt.
    """
    try:
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            timeout=300
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.exception("Error in generate_marketing_content")
        raise

def run_query(con, sql_query):
    try:
        df = con.execute(sql_query).fetchdf()
        return df
    except Exception as e:
        logging.exception("Error executing SQL query")
        st.error(f"Error executing SQL: {e}")
        return None

def main():
    st.title("Data Query & Visualization Dashboard")
    
    st.markdown("""
    This dashboard autonomously generates data queries and visualizations based on approved filter conditions.
    All data is pre-approved and non-sensitive.
    """)
    
    # Sidebar for options and debugging.
    debug_mode = st.sidebar.checkbox("Enable Debug Mode", value=False)
    
    st.sidebar.header("Query Options")
    nl_query = st.sidebar.text_input("Enter filter conditions:", "LOB = OH Care, Eligibility Date > 01/01/2025")
    viz_type = st.sidebar.selectbox("Preferred Visualization Type", options=["bar", "line", "pie", "auto"], index=3)
    
    # Set up the Azure OpenAI client.
    try:
        client = AzureOpenAI(
            api_version="2024-08-01-preview",
            azure_endpoint="https://dycsb0qcdmbjek0openai.openai.azure.com/",
            api_key="61708ba3ecb24abcbf691b8126feb905"
        )
    except Exception as e:
        st.exception(e)
        return

    # Load CSV data into DuckDB.
    try:
        csv_path = "FINAL_DATA_28JAN2025_29.csv"
        con = duckdb.connect(database=":memory:")
        con.execute(f"CREATE TABLE data AS SELECT * FROM read_csv_auto('{csv_path}');")
    except Exception as e:
        st.exception(e)
        return

    try:
        schema = con.execute("DESCRIBE data").fetchdf().to_string(index=False)
    except Exception as e:
        st.exception(e)
        return
    
    if st.sidebar.button("Run Query"):
        with st.spinner("Processing your query..."):
            # --- Part 1: Raw Data Query ---
            # (Internal prompt; SQL is not shown to end users unless debug mode is enabled.)
            prompt_raw = f"""
Generate a SQL query that retrieves records from the table 'data'
that satisfy these conditions: {nl_query}.
Return only the SQL query.
"""
            try:
                raw_sql = generate_sql(client, prompt_raw)
                if debug_mode:
                    st.text("Generated Raw SQL Query (debug):")
                    st.code(raw_sql, language="sql")
                raw_result = run_query(con, raw_sql)
                if raw_result is not None:
                    st.subheader("Data Results")
                    st.dataframe(raw_result)
                else:
                    st.error("No data returned from your query.")
            except Exception as e:
                if debug_mode:
                    st.exception(e)
                st.error("An error occurred while processing your data query.")
            
            # --- Part 2: Visualization Query ---
            # Simplified prompt that avoids sensitive language.
            prompt_vis = f"""
Generate a JSON object that includes a SQL query for aggregating data for visualization.
Use the table 'data' with these conditions: {nl_query}.
Return a JSON object with exactly these keys:
- "chart_type": a string (choose from "bar", "line", or "pie"; default to "{viz_type}" if unspecified),
- "labels": a list of column names,
- "aggregated_data": a SQL query that returns two columns: one for labels and one for numeric values.
Return only the JSON.
"""
            try:
                vis_output = generate_sql(client, prompt_vis)
                if debug_mode:
                    st.text("Generated Visualization Output (debug):")
                    st.code(vis_output, language="json")
                try:
                    vis_json = json.loads(vis_output)
                    vis_sql = vis_json.get("aggregated_data", "")
                    chart_type = vis_json.get("chart_type", viz_type if viz_type != "auto" else "bar")
                    labels = vis_json.get("labels", [])
                    if vis_sql:
                        vis_result = run_query(con, vis_sql)
                        st.subheader("Visualization")
                        st.dataframe(vis_result)
                        st.write(f"**Chart Type:** {chart_type}")
                        st.write(f"**Labels:** {labels}")
                        if vis_result is not None and not vis_result.empty:
                            try:
                                if chart_type == "bar":
                                    st.bar_chart(vis_result.set_index(vis_result.columns[0]))
                                elif chart_type == "line":
                                    st.line_chart(vis_result.set_index(vis_result.columns[0]))
                                elif chart_type == "pie":
                                    import plotly.express as px
                                    fig = px.pie(vis_result, names=vis_result.columns[0], values=vis_result.columns[1])
                                    st.plotly_chart(fig)
                                else:
                                    st.write("Unknown chart type.")
                            except Exception as plot_e:
                                if debug_mode:
                                    st.exception(plot_e)
                                st.error(f"Error visualizing data: {plot_e}")
                        else:
                            st.write("No aggregated data available for visualization.")
                    else:
                        st.error("Visualization output did not include aggregated data.")
                except Exception as parse_e:
                    if debug_mode:
                        st.exception(parse_e)
                    st.error("Error processing visualization output.")
            except Exception as e:
                if debug_mode:
                    st.exception(e)
                st.error("An error occurred while generating the visualization query.")
            
            # --- Part 3: Marketing Content Generation ---
            if st.sidebar.checkbox("Generate Marketing Content"):
                business = st.sidebar.text_input("Business Name:", "Your Business")
                campaign = st.sidebar.text_area("Campaign Description:", "Campaign details...")
                channels = st.sidebar.text_input("Preferred Channels (comma-separated):", "SMS, LinkedIn, Direct Mail, Email")
                prompt_content = f"""
Generate multi-channel marketing content for the following:
Business: {business}
Campaign: {campaign}
Filter Conditions: {nl_query}
Preferred Channels: {channels}
Return a JSON object with keys for each channel.
"""
                try:
                    marketing_output = generate_marketing_content(client, prompt_content)
                    st.subheader("Marketing Content")
                    st.code(marketing_output, language="json")
                except Exception as e:
                    if debug_mode:
                        st.exception(e)
                    st.error("An error occurred while generating marketing content.")
            
if __name__ == "__main__":
    main()
```

---

### Running the App

1. Save the code as **streamlit_app.py**.  
2. Run the app using the command:  
   ```bash
   streamlit run streamlit_app.py
   ```
3. Use the sidebar to enter your approved filter conditions and choose a visualization type.  
4. Click "Run Query" to see data results and a visualization.  
5. (Optional) Check the "Generate Marketing Content" checkbox to produce multi‑channel content.  
6. Enable "Debug Mode" in the sidebar if you need to see internal details during development.

This setup keeps your SQL generation process autonomous and hidden from end users while still providing robust error reporting and debugging when needed.
