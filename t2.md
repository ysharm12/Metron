You can add logging and more robust error reporting to help you debug any background errors. For example, you might:

1. **Use Python's built‑in logging module** to log errors to the console or a file.
2. **Wrap critical sections in try/except blocks** and use Streamlit’s `st.exception()` (or `st.error()`) to display full tracebacks when debug mode is enabled.
3. **Add a sidebar checkbox to enable debug mode** so that detailed error messages (or logging) are only shown when desired.

Below is a modified version of your Streamlit app that demonstrates these techniques:

```python
import streamlit as st
import duckdb
import re
import json
import logging
from openai import AzureOpenAI

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(),  # Log to console
        logging.FileHandler("app_debug.log", mode="w")  # Log to file (overwrites each run)
    ]
)

def generate_sql(client, prompt, model="o1-preview"):
    try:
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            timeout=300
        )
        raw_output = response.choices[0].message.content.strip()
        pattern = r"```(?:sql)?\s*(.*?)\s*```"
        match = re.search(pattern, raw_output, re.DOTALL)
        if match:
            return match.group(1).strip()
        else:
            return raw_output
    except Exception as e:
        logging.exception("Error in generate_sql")
        raise

def generate_marketing_content(client, prompt, model="o1-preview"):
    try:
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            timeout=300
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.exception("Error in generate_marketing_content")
        raise

def run_query(con, sql_query):
    try:
        df = con.execute(sql_query).fetchdf()
        return df
    except Exception as e:
        logging.exception("Error executing SQL query")
        st.error(f"Error executing SQL: {e}")
        return None

def main():
    st.title("Data Query & Visualization Dashboard")
    
    # Option to enable debug mode
    debug_mode = st.sidebar.checkbox("Enable Debug Mode", value=False)
    
    st.markdown("""
    This dashboard autonomously generates data queries and visualizations based on approved filter conditions.
    All data has been pre-approved by the business.
    """)
    
    try:
        # Set up the Azure OpenAI client.
        client = AzureOpenAI(
            api_version="2024-08-01-preview",
            azure_endpoint="https://dycsb0qcdmbjek0openai.openai.azure.com/",
            api_key="61708ba3ecb24abcbf691b8126feb905"
        )
    except Exception as e:
        st.exception(e)
        return

    try:
        # Load CSV data into DuckDB (in-memory).
        csv_path = "FINAL_DATA_28JAN2025_29.csv"
        con = duckdb.connect(database=":memory:")
        con.execute(f"CREATE TABLE data AS SELECT * FROM read_csv_auto('{csv_path}');")
    except Exception as e:
        st.exception(e)
        return

    try:
        # Retrieve the table schema.
        schema = con.execute("DESCRIBE data").fetchdf().to_string(index=False)
    except Exception as e:
        st.exception(e)
        return
    
    st.sidebar.header("Query Options")
    nl_query = st.sidebar.text_input("Enter your query (approved filter conditions):", "LOB = OH Care, Eligibility Date > 01/01/2025")
    viz_type = st.sidebar.selectbox("Preferred Visualization Type", options=["bar", "line", "pie", "auto"], index=3)
    
    if st.sidebar.button("Run Query"):
        with st.spinner("Processing your query..."):
            # --- Part 1: Raw Data Query ---
            prompt_raw = f"""
Generate a SQL query that retrieves data from the table 'data'
matching these filter conditions: {nl_query}
Return only the SQL query.
"""
            try:
                raw_sql = generate_sql(client, prompt_raw)
                if debug_mode:
                    st.text("Generated Raw SQL Query (debug):")
                    st.code(raw_sql, language="sql")
                raw_result = run_query(con, raw_sql)
                if raw_result is not None:
                    st.subheader("Data Results")
                    st.dataframe(raw_result)
                else:
                    st.error("No data returned from your query.")
            except Exception as e:
                if debug_mode:
                    st.exception(e)
                st.error("An error occurred while generating the raw data query.")
            
            # --- Part 2: Visualization Query ---
            prompt_vis = f"""
Generate a JSON object that includes a SQL query for aggregating data for visualization.
Use the table 'data' with these filter conditions: {nl_query}
Return a JSON object with exactly these keys:
- "chart_type": a string (choose from "bar", "line", or "pie"; default to "{viz_type}" if unspecified),
- "labels": a list of labels,
- "aggregated_data": a SQL query that returns two columns: one for labels and one for numeric values.
Return only the JSON.
"""
            try:
                vis_output = generate_sql(client, prompt_vis)
                if debug_mode:
                    st.text("Generated Visualization Output (debug):")
                    st.code(vis_output, language="json")
                try:
                    vis_json = json.loads(vis_output)
                    vis_sql = vis_json.get("aggregated_data", "")
                    chart_type = vis_json.get("chart_type", viz_type if viz_type != "auto" else "bar")
                    labels = vis_json.get("labels", [])
                    if vis_sql:
                        vis_result = run_query(con, vis_sql)
                        st.subheader("Visualization")
                        st.dataframe(vis_result)
                        st.write(f"**Chart Type:** {chart_type}")
                        st.write(f"**Labels:** {labels}")
                        if vis_result is not None and not vis_result.empty:
                            try:
                                if chart_type == "bar":
                                    st.bar_chart(vis_result.set_index(vis_result.columns[0]))
                                elif chart_type == "line":
                                    st.line_chart(vis_result.set_index(vis_result.columns[0]))
                                elif chart_type == "pie":
                                    import plotly.express as px
                                    fig = px.pie(vis_result, names=vis_result.columns[0], values=vis_result.columns[1])
                                    st.plotly_chart(fig)
                                else:
                                    st.write("Unknown chart type.")
                            except Exception as plot_e:
                                if debug_mode:
                                    st.exception(plot_e)
                                st.error(f"Error visualizing data: {plot_e}")
                        else:
                            st.write("No aggregated data available for visualization.")
                    else:
                        st.error("Visualization output did not include aggregated data.")
                except Exception as parse_e:
                    if debug_mode:
                        st.exception(parse_e)
                    st.error("Error processing visualization output.")
            except Exception as e:
                if debug_mode:
                    st.exception(e)
                st.error("An error occurred while generating the visualization query.")
            
            # --- Part 3: Marketing Content Generation ---
            if st.sidebar.checkbox("Generate Marketing Content"):
                business = st.sidebar.text_input("Business Name:", "Your Business")
                campaign = st.sidebar.text_area("Campaign Description:", "Campaign details...")
                channels = st.sidebar.text_input("Preferred Channels (comma-separated):", "SMS, LinkedIn, Direct Mail, Email")
                prompt_content = f"""
Generate marketing content for the following details.
Business: {business}
Campaign: {campaign}
Filter Conditions: {nl_query}
Preferred Channels: {channels}
Return a JSON object with keys for each channel.
"""
                try:
                    marketing_output = generate_marketing_content(client, prompt_content)
                    st.subheader("Marketing Content")
                    st.code(marketing_output, language="json")
                except Exception as e:
                    if debug_mode:
                        st.exception(e)
                    st.error("An error occurred while generating marketing content.")
            
if __name__ == "__main__":
    main()
```

---

### How This Enhances Debugging

- **Logging & Exception Capture:**  
  Each function (and critical code block) has a try/except block that logs the exception (using `logging.exception`) and optionally shows the full traceback with `st.exception()` if debug mode is enabled.

- **Debug Mode Option:**  
  A sidebar checkbox lets you enable debug mode. When enabled, the app will display internal details such as the generated SQL and full error tracebacks, which can help you pinpoint issues during development.

- **User-Friendly Errors:**  
  In non-debug mode, only user-friendly error messages are displayed via `st.error()`, keeping the internal details hidden from end users.

This setup should help you catch and debug errors in the background while keeping the production interface clean.
