Below is a complete Streamlit front‑end application that meets your requirements. It uses DuckDB to load your CSV data and Azure OpenAI (via the OpenAI Python package configured for Azure) to autonomously generate SQL queries and visualizations based on approved filter conditions. The prompts have been simplified so that they do not expose the underlying SQL to the end user. Instead, the raw SQL generation is completely hidden, and only the final data and visualization are shown. In addition, a separate section allows the user to generate multi‑channel marketing content based on the approved query. 

Save the code below as, for example, **streamlit_app.py** and run it with:

```bash
streamlit run streamlit_app.py
```

Here’s the code:

```python
import streamlit as st
import duckdb
import re
import json
from openai import AzureOpenAI

def generate_sql(client, prompt, model="o1-preview"):
    """
    Generate a SQL query or JSON output from a natural language prompt.
    """
    response = client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": prompt}],
        timeout=300
    )
    raw_output = response.choices[0].message.content.strip()
    pattern = r"```(?:sql)?\s*(.*?)\s*```"
    match = re.search(pattern, raw_output, re.DOTALL)
    if match:
        return match.group(1).strip()
    else:
        return raw_output

def generate_marketing_content(client, prompt, model="o1-preview"):
    """
    Generate multi-channel marketing content from a prompt.
    """
    response = client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": prompt}],
        timeout=300
    )
    return response.choices[0].message.content.strip()

def run_query(con, sql_query):
    try:
        df = con.execute(sql_query).fetchdf()
        return df
    except Exception as e:
        st.error(f"Error executing SQL: {e}")
        return None

def main():
    st.title("Data Query & Visualization Dashboard")
    
    st.markdown("""
    This dashboard autonomously generates data queries and visualizations based on approved filter conditions.
    All data has been pre-approved by the business, so you need only provide your filter criteria.
    """)
    
    # Set up the Azure OpenAI client.
    client = AzureOpenAI(
        api_version="2024-08-01-preview",
        azure_endpoint="https://dycsb0qcdmbjek0openai.openai.azure.com/",
        api_key="61708ba3ecb24abcbf691b8126feb905"
    )
    
    # Load CSV data into DuckDB (in-memory).
    csv_path = "FINAL_DATA_28JAN2025_29.csv"
    con = duckdb.connect(database=":memory:")
    con.execute(f"CREATE TABLE data AS SELECT * FROM read_csv_auto('{csv_path}');")
    
    # Retrieve the table schema.
    schema = con.execute("DESCRIBE data").fetchdf().to_string(index=False)
    
    st.sidebar.header("Query Options")
    nl_query = st.sidebar.text_input("Enter approved filter conditions:", "LOB = OH Care, Eligibility Date > 01/01/2025")
    viz_type = st.sidebar.selectbox("Preferred Visualization Type", options=["bar", "line", "pie", "auto"], index=3)
    
    if st.sidebar.button("Run Query"):
        with st.spinner("Processing your query..."):
            # --- Part 1: Raw Data Query (Autonomous SQL generation) ---
            # The prompt is kept simple and does not reveal internal processing.
            prompt_raw = f"""
Generate a SQL query that retrieves data from the table 'data'
matching these filter conditions: {nl_query}
Return only the SQL query.
"""
            raw_sql = generate_sql(client, prompt_raw)
            raw_result = run_query(con, raw_sql)
            
            if raw_result is not None:
                st.subheader("Data Results")
                st.dataframe(raw_result)
            else:
                st.error("No data returned from your query.")
            
            # --- Part 2: Visualization Query ---
            prompt_vis = f"""
Generate a JSON object that includes a SQL query for aggregating data for visualization.
Use the table 'data' and the following filter conditions: {nl_query}
Return a JSON object with exactly these keys:
- "chart_type": a string (choose from "bar", "line", or "pie"; default to "{viz_type}" if unspecified),
- "labels": a list of labels,
- "aggregated_data": a SQL query that returns two columns: one for labels and one for numeric values.
Return only the JSON.
"""
            vis_output = generate_sql(client, prompt_vis)
            try:
                vis_json = json.loads(vis_output)
                vis_sql = vis_json.get("aggregated_data", "")
                chart_type = vis_json.get("chart_type", viz_type if viz_type != "auto" else "bar")
                labels = vis_json.get("labels", [])
                if vis_sql:
                    vis_result = run_query(con, vis_sql)
                    st.subheader("Visualization")
                    st.dataframe(vis_result)
                    st.write(f"**Chart Type:** {chart_type}")
                    st.write(f"**Labels:** {labels}")
                    if vis_result is not None and not vis_result.empty:
                        try:
                            if chart_type == "bar":
                                st.bar_chart(vis_result.set_index(vis_result.columns[0]))
                            elif chart_type == "line":
                                st.line_chart(vis_result.set_index(vis_result.columns[0]))
                            elif chart_type == "pie":
                                import plotly.express as px
                                fig = px.pie(vis_result, names=vis_result.columns[0], values=vis_result.columns[1])
                                st.plotly_chart(fig)
                            else:
                                st.write("Unknown chart type.")
                        except Exception as plot_e:
                            st.error(f"Error visualizing data: {plot_e}")
                    else:
                        st.write("No aggregated data available for visualization.")
                else:
                    st.error("Visualization output did not include aggregated data.")
            except Exception as e:
                st.error(f"Error processing visualization output: {e}")
            
            # --- Part 3: Marketing Content Generation ---
            if st.sidebar.checkbox("Generate Marketing Content"):
                business = st.sidebar.text_input("Business Name:", "Your Business")
                campaign = st.sidebar.text_area("Campaign Description:", "Campaign details...")
                channels = st.sidebar.text_input("Preferred Channels (comma-separated):", "SMS, LinkedIn, Direct Mail, Email")
                prompt_content = f"""
Generate multi-channel marketing content for the following:
Business: {business}
Campaign: {campaign}
Filter Conditions: {nl_query}
Preferred Channels: {channels}
Return a JSON object with keys for each channel.
"""
                marketing_output = generate_marketing_content(client, prompt_content)
                st.subheader("Marketing Content")
                st.code(marketing_output, language="json")
            
if __name__ == "__main__":
    main()
```

---

### How It Works

- **Streamlit UI:**  
  The sidebar accepts approved filter conditions, a preferred visualization type, and (optionally) business and campaign details for generating marketing content.  
- **Autonomous SQL Generation:**  
  The raw SQL and visualization queries are generated internally by Azure OpenAI based on simple prompts (which do not reveal internal SQL logic to the end user).  
- **Data & Visualization:**  
  Raw data results and aggregated (visualization) results are displayed. If a pie chart is requested, Plotly is used for rendering.  
- **Marketing Content:**  
  Upon request, the app generates multi‑channel marketing content in JSON format.

Simply run the app with `streamlit run streamlit_app.py` and use the sidebar to interact with your dashboard.
