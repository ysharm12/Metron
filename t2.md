Below is an example of a complete Streamlit application that acts as a front‑end for your data query and visualization pipeline. In this app, the user enters a natural language query. When the query is fired, two prompts are sent to Azure OpenAI:

1. One to generate a raw SQL query to retrieve data.
2. One to generate a JSON output containing an aggregated SQL query plus visualization instructions (chart type and labels).

Then the app displays the raw query result and—if available—runs the aggregated query and uses Streamlit’s charting functions (you can extend it to use Plotly or others) to visualize the data. Finally, the user is given an option to generate multi‑channel marketing content based on the query.

> **Note:** In the visualization prompt we’ve added explicit instructions so that the response is a JSON object containing only the keys `"chart_type"`, `"labels"`, and `"aggregated_data"`. If the LLM doesn’t have enough information to generate one, it may reply with a clarification message—so you may want to try a more detailed query or adjust the prompt further.

Save the code below as (for example) **streamlit_app.py**, then run with `streamlit run streamlit_app.py`.

---

```python
import streamlit as st
import duckdb
import re
import json
from openai import AzureOpenAI

def generate_sql(client, prompt, model="o1-preview"):
    """
    Generate a SQL query or JSON output from a natural language prompt.
    Extracts the generated text from the chat completion message.
    """
    response = client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": prompt}],
        timeout=300
    )
    raw_output = response.choices[0].message.content.strip()
    # If wrapped in triple backticks (and maybe with "sql"), extract the inner text.
    pattern = r"```(?:sql)?\s*(.*?)\s*```"
    match = re.search(pattern, raw_output, re.DOTALL)
    if match:
        return match.group(1).strip()
    else:
        return raw_output

def generate_marketing_content(client, prompt, model="o1-preview"):
    """
    Generate multi-channel marketing content from a prompt.
    """
    response = client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": prompt}],
        timeout=300
    )
    return response.choices[0].message.content.strip()

def run_query(con, sql_query):
    try:
        df = con.execute(sql_query).fetchdf()
        return df
    except Exception as e:
        st.error(f"Error executing SQL: {e}")
        return None

def main():
    st.title("Natural Language Data Query and Visualization")
    
    st.markdown("""
    This application uses Azure OpenAI and DuckDB to convert your natural language queries into SQL queries.
    You can obtain both raw data and an aggregated visualization query. Finally, you have the option to generate multi‑channel marketing content.
    """)
    
    # Set up the Azure OpenAI client.
    client = AzureOpenAI(
        api_version="2024-08-01-preview",
        azure_endpoint="https://dycsb0qcdmbjek0openai.openai.azure.com/",
        api_key="61708ba3ecb24abcbf691b8126feb905"
    )
    
    # Load CSV data into DuckDB (in-memory).
    csv_path = "FINAL_DATA_28JAN2025_29.csv"
    con = duckdb.connect(database=':memory:')
    con.execute(f"CREATE TABLE data AS SELECT * FROM read_csv_auto('{csv_path}');")
    
    # Retrieve the table schema.
    schema = con.execute("DESCRIBE data").fetchdf().to_string(index=False)
    
    st.sidebar.header("Query Options")
    nl_query = st.sidebar.text_input("Enter your query (e.g., filter conditions):", "LOB = OH Care, Eligibility Date > 01/01/2025")
    
    # Visualization type selector (optional: user can force a chart type)
    viz_type = st.sidebar.selectbox("Preferred Visualization Type", options=["bar", "line", "pie", "auto"], index=3)
    
    if st.sidebar.button("Run Query"):
        st.subheader("Raw Data Query")
        prompt_raw = f"""
You are a SQL generator.
Given the following table schema from a DuckDB table named 'data':
{schema}

Write a SQL query that fulfills this request:
"{nl_query}"
Provide only the SQL query.
Make sure to use the table name 'data'.
"""
        raw_sql = generate_sql(client, prompt_raw)
        st.code(raw_sql, language="sql")
        raw_result = run_query(con, raw_sql)
        if raw_result is not None:
            st.dataframe(raw_result)
        
        st.subheader("Visualization Query")
        # Visualization prompt: instruct the LLM to return a JSON with specific keys.
        prompt_vis = f"""
You are a SQL generator specialized in data visualization.
Given the following table schema from a DuckDB table named 'data':
{schema}

Write a SQL query that aggregates the data to support visualization for the following request:
"{nl_query}"
Return the result in JSON format with exactly the following keys:
- "chart_type": a string representing the type of chart (choose from "bar", "line", or "pie"). 
  If the query does not specify, use "{viz_type}" unless "auto" is selected.
- "labels": a list of column names that will serve as labels.
- "aggregated_data": an SQL query that when executed returns two columns: one for labels and one for numeric values.
Make sure to use the table name 'data'.
Provide only the JSON object (with no extra commentary).
"""
        vis_output = generate_sql(client, prompt_vis)
        st.code(vis_output, language="json")
        try:
            vis_json = json.loads(vis_output)
            vis_sql = vis_json.get("aggregated_data", "")
            chart_type = vis_json.get("chart_type", viz_type if viz_type != "auto" else "bar")
            labels = vis_json.get("labels", [])
            if vis_sql:
                vis_result = run_query(con, vis_sql)
                st.subheader("Visualization Data Query Result")
                st.dataframe(vis_result)
                st.write(f"**Chart Type:** {chart_type}")
                st.write(f"**Labels:** {labels}")
                if vis_result is not None and not vis_result.empty:
                    # For simplicity, we assume the aggregated query returns two columns: label and value.
                    # You can customize this part based on your actual aggregated data.
                    try:
                        # Try to plot using streamlit's built-in chart functions.
                        if chart_type == "bar":
                            st.bar_chart(vis_result.set_index(vis_result.columns[0]))
                        elif chart_type == "line":
                            st.line_chart(vis_result.set_index(vis_result.columns[0]))
                        elif chart_type == "pie":
                            # Pie charts are not directly supported by streamlit; we can use Plotly.
                            import plotly.express as px
                            fig = px.pie(vis_result, names=vis_result.columns[0], values=vis_result.columns[1])
                            st.plotly_chart(fig)
                        else:
                            st.write("Unknown chart type.")
                    except Exception as plot_e:
                        st.error(f"Error visualizing data: {plot_e}")
                else:
                    st.write("No data returned from visualization query.")
            else:
                st.error("No 'aggregated_data' SQL found in the JSON output.")
        except Exception as e:
            st.error(f"Error parsing visualization output as JSON: {e}")
        
        st.subheader("Marketing Content Generation")
        if st.sidebar.checkbox("Generate Marketing Content"):
            business = st.sidebar.text_input("Enter business name:", "Your Business")
            campaign = st.sidebar.text_area("Enter campaign description:", "Campaign details...")
            channels = st.sidebar.text_input("Enter preferred channels (comma-separated):", "SMS, LinkedIn, Direct Mail, Email")
            prompt_content = f"""
You are a marketing content generator.
Business: {business}
Campaign: {campaign}
Preferred Channels: {channels}
Based on the following data query: "{nl_query}"
Generate marketing content for each channel (SMS, LinkedIn, Direct Mail, Email) in JSON format.
The JSON should have keys corresponding to each channel.
Provide only the JSON output.
"""
            marketing_output = generate_marketing_content(client, prompt_content)
            st.subheader("Generated Marketing Content")
            st.code(marketing_output, language="json")
            
if __name__ == "__main__":
    main()
```

---

### How It Works

- **Streamlit UI:**  
  The sidebar contains inputs for the natural language query, a selector for preferred visualization type, and options to generate marketing content.

- **Data Loading & Schema:**  
  The CSV file is loaded into an in‑memory DuckDB table called `"data"`, and its schema is displayed to help guide the SQL generator.

- **Raw SQL Query Generation:**  
  The app generates a raw SQL query from the natural language input and displays the results.

- **Visualization Query Generation:**  
  The app sends a visualization-specific prompt to the LLM asking for a JSON response. This JSON must contain a chart type, labels, and an aggregated SQL query. The aggregated query is executed, and the results are visualized using Streamlit’s charting tools (with a fallback to Plotly for pie charts).

- **Marketing Content Generation:**  
  Optionally, the user can generate marketing content across channels by filling in business, campaign, and channel details. The generated JSON is then displayed.

### Running the App

1. Save the code to **streamlit_app.py**.
2. In your terminal, run:
   ```bash
   streamlit run streamlit_app.py
   ```
3. The app will open in your browser. Use the sidebar inputs to enter your query and other parameters, then click the button to run the query.

This structure lets you have a single front‑end application that not only fires off two SQL queries (raw and aggregated for visualization) but also produces visualizations and multi‑channel marketing content—all powered by Azure OpenAI.
